<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 이미지 에디터</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel (JSX 변환용) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* 커스텀 스크롤바 */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1; 
        }
        ::-webkit-scrollbar-thumb {
            background: #c7c7c7; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8; 
        }
    </style>
</head>
<body class="bg-gray-900 text-white">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // --- 아이콘 컴포넌트 정의 ---
        const IconBase = ({ size = 24, className = "", children }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );

        const Upload = (props) => <IconBase {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></IconBase>;
        const RotateCw = (props) => <IconBase {...props}><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/></IconBase>;
        const RotateCcw = (props) => <IconBase {...props}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></IconBase>;
        const FlipHorizontal = (props) => <IconBase {...props}><path d="M8 3H5a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h3"/><path d="M16 3h3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-3"/><path d="M12 3v18"/></IconBase>;
        const FlipVertical = (props) => <IconBase {...props}><path d="M21 8v3H3V8"/><path d="M21 16v-3H3v3"/><path d="M3 5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2"/><path d="M3 19a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2"/></IconBase>;
        const RefreshCcw = (props) => <IconBase {...props}><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 21h5v-5"/></IconBase>;
        const Sun = (props) => <IconBase {...props}><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></IconBase>;
        const Contrast = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><path d="M12 18a6 6 0 0 0 0-12v12z"/></IconBase>;
        const Droplet = (props) => <IconBase {...props}><path d="M12 22a7 7 0 0 0 7-7c0-2-1-3.9-3-5.5s-3.5-4-4-6.5c-.5 2.5-2 4.9-4 6.5C6 11.1 5 13 5 15a7 7 0 0 0 7 7z"/></IconBase>;
        const Activity = (props) => <IconBase {...props}><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></IconBase>;
        const ImageIcon = (props) => <IconBase {...props}><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></IconBase>;
        const Sliders = (props) => <IconBase {...props}><line x1="4" x2="4" y1="21" y2="14"/><line x1="4" x2="4" y1="10" y2="3"/><line x1="12" x2="12" y1="21" y2="12"/><line x1="12" x2="12" y1="8" y2="3"/><line x1="20" x2="20" y1="21" y2="16"/><line x1="20" x2="20" y1="12" y2="3"/><line x1="2" x2="6" y1="14" y2="14"/><line x1="10" x2="14" y1="8" y2="8"/><line x1="18" x2="22" y1="16" y2="16"/></IconBase>;
        const Move = (props) => <IconBase {...props}><polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="19 9 22 12 19 15"/><polyline points="15 19 12 22 9 19"/><line x1="2" x2="22" y1="12" y2="12"/><line x1="12" x2="12" y1="2" y2="22"/></IconBase>;
        const Trash2 = (props) => <IconBase {...props}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></IconBase>;
        const Scaling = (props) => <IconBase {...props}><path d="M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M14 15H9v-5"/><path d="M16 3h5v5"/><path d="M21 3 9 15"/></IconBase>;
        const Lock = (props) => <IconBase {...props}><rect width="18" height="11" x="3" y="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></IconBase>;
        const Unlock = (props) => <IconBase {...props}><rect width="18" height="11" x="3" y="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 9.9-1"/></IconBase>;
        const Wand2 = (props) => <IconBase {...props}><path d="m19 2 2 2-2 2-2-2 2-2Z"/><path d="m5 2 2 2-2 2-2-2 2-2Z"/><path d="m15 11 2 2-2 2-2-2 2-2Z"/><path d="M6 16c2.8.6 4.4 2.4 5 5l8-8c1-1 1-2.5 0-3.5L14.5 5c-1-1-2.5-1-3.5 0L6 16Z"/></IconBase>;
        const Loader2 = (props) => <IconBase {...props}><path d="M21 12a9 9 0 1 1-6.219-8.56"/></IconBase>;
        const HardDrive = (props) => <IconBase {...props}><line x1="22" x2="2" y1="12" y2="12"/><path d="M5.45 5.11 2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"/><line x1="6" x2="6.01" y1="16" y2="16"/><line x1="10" x2="10.01" y1="16" y2="16"/></IconBase>;
        const Save = (props) => <IconBase {...props}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></IconBase>;
        const Sparkles = (props) => <IconBase {...props}><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M9 3v4"/><path d="M3 5h4"/><path d="M3 9h4"/></IconBase>;


        function App() {
            const [image, setImage] = useState(null);
            const [originalDimensions, setOriginalDimensions] = useState({ w: 0, h: 0 });
            const [currentFileSize, setCurrentFileSize] = useState(0); 
            const [activeTab, setActiveTab] = useState('adjust');
            const [isDragging, setIsDragging] = useState(false);
            const [isProcessing, setIsProcessing] = useState(false); 
            
            const [saveFormat, setSaveFormat] = useState('png');
            
            // --- AI 품질 관련 상태 추가 ---
            const [highQuality, setHighQuality] = useState(false);
            const [smoothEdges, setSmoothEdges] = useState(true);

            const [filters, setFilters] = useState({
                brightness: 100, contrast: 100, saturation: 100, blur: 0, hue: 0, sepia: 0, grayscale: 0,
            });

            const [transform, setTransform] = useState({ rotate: 0, flipH: 1, flipV: 1 });
            const [resize, setResize] = useState({ width: 0, height: 0, locked: true });
            const [targetKb, setTargetKb] = useState(500);

            const fileInputRef = useRef(null);

            const loadScript = (src) => {
                return new Promise((resolve, reject) => {
                    if (document.querySelector(`script[src="${src}"]`)) { resolve(); return; }
                    const script = document.createElement('script');
                    script.src = src;
                    script.onload = resolve;
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
            };

            const calculateBase64Size = (base64String) => {
                let padding = 0;
                if (base64String.endsWith('==')) padding = 2;
                else if (base64String.endsWith('=')) padding = 1;
                return (base64String.length * (3/4)) - padding;
            };

            useEffect(() => {
                if (image) {
                    const size = calculateBase64Size(image);
                    setCurrentFileSize(size);
                }
            }, [image]);

            const processFile = (file) => {
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            setOriginalDimensions({ w: img.width, h: img.height });
                            setResize({ width: img.width, height: img.height, locked: true });
                            setImage(event.target.result);
                            resetEdits();
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                } else {
                    alert("이미지 파일만 업로드 가능합니다.");
                }
            };

            const handleImageUpload = (e) => processFile(e.target.files[0]);
            const handleDragOver = (e) => { e.preventDefault(); setIsDragging(true); };
            const handleDragLeave = (e) => { e.preventDefault(); setIsDragging(false); };
            const handleDrop = (e) => { e.preventDefault(); setIsDragging(false); processFile(e.dataTransfer.files[0]); };

            const resetEdits = () => {
                setFilters({ brightness: 100, contrast: 100, saturation: 100, blur: 0, hue: 0, sepia: 0, grayscale: 0 });
                setTransform({ rotate: 0, flipH: 1, flipV: 1 });
            };

            const handleTabChange = (tabId) => setActiveTab(tabId);

            const handleResizeChange = (key, value) => {
                const newVal = Number(value);
                if (resize.locked) {
                    const ratio = originalDimensions.w / originalDimensions.h;
                    if (key === 'width') setResize(prev => ({ ...prev, width: newVal, height: Math.round(newVal / ratio) }));
                    else setResize(prev => ({ ...prev, height: newVal, width: Math.round(newVal * ratio) }));
                } else {
                    setResize(prev => ({ ...prev, [key]: newVal }));
                }
            };

            const applyPreset = (presetName) => {
                const baseFilters = { brightness: 100, contrast: 100, saturation: 100, blur: 0, hue: 0, sepia: 0, grayscale: 0 };
                switch (presetName) {
                    case 'grayscale': setFilters({ ...baseFilters, grayscale: 100 }); break;
                    case 'sepia': setFilters({ ...baseFilters, sepia: 100 }); break;
                    case 'vintage': setFilters({ ...baseFilters, sepia: 50, contrast: 85, brightness: 110 }); break;
                    case 'beauty': setFilters({ ...baseFilters, brightness: 110, contrast: 95, saturation: 105, blur: 0.3 }); break;
                    case 'sharp': setFilters({ ...baseFilters, contrast: 120, saturation: 110 }); break;
                    case 'soft': setFilters({ ...baseFilters, brightness: 105, contrast: 90, saturation: 90 }); break;
                    case 'clear': setFilters({ ...baseFilters, brightness: 108, contrast: 108, saturation: 110 }); break;
                    case 'intense': setFilters({ ...baseFilters, contrast: 130, saturation: 140 }); break;
                    case 'warm': setFilters({ ...baseFilters, sepia: 30, brightness: 105, saturation: 110 }); break;
                    case 'cool': setFilters({ ...baseFilters, brightness: 105, contrast: 110, saturation: 90, hue: 0 }); break;
                    default: setFilters(baseFilters); break;
                }
            };

            const compressToTargetSize = () => {
                if (!image) return;
                setIsProcessing(true);
                setTimeout(() => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    img.onload = () => {
                        canvas.width = resize.width;
                        canvas.height = resize.height;
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.filter = `brightness(${filters.brightness}%) contrast(${filters.contrast}%) saturate(${filters.saturation}%) blur(${filters.blur}px) hue-rotate(${filters.hue}deg) sepia(${filters.sepia}%) grayscale(${filters.grayscale}%)`;
                        ctx.translate(canvas.width / 2, canvas.height / 2);
                        ctx.rotate((transform.rotate * Math.PI) / 180);
                        ctx.scale(transform.flipH, transform.flipV);
                        const isRotated = transform.rotate % 180 !== 0;
                        const drawW = isRotated ? canvas.height : canvas.width;
                        const drawH = isRotated ? canvas.width : canvas.height;
                        ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
                        
                        let minQ = 0.01, maxQ = 1.0, bestUrl = canvas.toDataURL('image/jpeg', 0.5), attempts = 0;
                        const targetBytes = targetKb * 1024;
                        while (attempts < 10) { 
                            const midQ = (minQ + maxQ) / 2;
                            const resultUrl = canvas.toDataURL('image/jpeg', midQ);
                            const size = calculateBase64Size(resultUrl);
                            if (Math.abs(size - targetBytes) < targetBytes * 0.05) { bestUrl = resultUrl; break; }
                            if (size > targetBytes) maxQ = midQ; else { minQ = midQ; bestUrl = resultUrl; }
                            attempts++;
                        }
                        setImage(bestUrl);
                        resetEdits(); 
                        setOriginalDimensions({w: resize.width, h: resize.height}); 
                        setIsProcessing(false);
                    };
                    img.src = image;
                }, 100);
            };

            const removeBackground = async () => {
                if (!image) return;
                setIsProcessing(true);

                try {
                    await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js');
                    await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.2.0/dist/body-pix.min.js');

                    if (window.tf) {
                        await window.tf.ready();
                        window.tf.env().set('WEBGL_PACK', false);
                        try { await window.tf.setBackend('webgl'); } 
                        catch (err) { await window.tf.setBackend('cpu'); }
                    }

                    // 모델 로드 설정: 고화질 모드면 해상도(internalResolution)를 높게, 아니면 중간으로 설정
                    // BodyPix의 internalResolution: 'low', 'medium', 'high', 'full'
                    // highQuality 체크 시 0.75(high) 이상 사용
                    const resolution = highQuality ? 'high' : 'medium'; 
                    const net = await window.bodyPix.load({
                        architecture: 'ResNet50',
                        outputStride: 32,
                        quantBytes: 4
                    });

                    const imgElement = document.createElement('img');
                    imgElement.src = image;
                    imgElement.crossOrigin = "anonymous";
                    await new Promise(resolve => imgElement.onload = resolve);

                    // --- 리사이징 제한 ---
                    // 고화질 모드면 최대 2048px까지 허용, 일반 모드면 1280px (메모리 보호)
                    const MAX_DIMENSION = highQuality ? 2048 : 1280; 
                    let w = imgElement.width;
                    let h = imgElement.height;
                    
                    if (w > MAX_DIMENSION || h > MAX_DIMENSION) {
                        const ratio = w / h;
                        if (w > h) { w = MAX_DIMENSION; h = MAX_DIMENSION / ratio; } 
                        else { h = MAX_DIMENSION; w = MAX_DIMENSION * ratio; }
                    }
                    
                    const processCanvas = document.createElement('canvas');
                    processCanvas.width = w;
                    processCanvas.height = h;
                    const processCtx = processCanvas.getContext('2d');
                    processCtx.drawImage(imgElement, 0, 0, w, h);

                    // AI 분석
                    const segmentation = await net.segmentPerson(processCanvas, {
                        internalResolution: resolution, 
                        segmentationThreshold: 0.7,
                        scoreThreshold: 0.5,
                        maxDetections: 1
                    });

                    // --- 고품질 마스킹 처리 (Feathering / Blur) ---
                    // 단순히 픽셀을 자르는 것이 아니라, 마스크를 생성하고 부드럽게 블러 처리하여 합칩니다.
                    
                    // 1. 마스크 데이터 생성 (배경은 투명, 사람은 검정)
                    const maskCanvas = document.createElement('canvas');
                    maskCanvas.width = w;
                    maskCanvas.height = h;
                    const maskCtx = maskCanvas.getContext('2d');
                    const maskImageData = maskCtx.createImageData(w, h);
                    const maskData = maskImageData.data;

                    for (let i = 0; i < segmentation.data.length; i++) {
                        const isPerson = segmentation.data[i] === 1;
                        const pixelIndex = i * 4;
                        maskData[pixelIndex] = 0;     // R
                        maskData[pixelIndex + 1] = 0; // G
                        maskData[pixelIndex + 2] = 0; // B
                        maskData[pixelIndex + 3] = isPerson ? 255 : 0; // Alpha (사람만 255)
                    }
                    maskCtx.putImageData(maskImageData, 0, 0);

                    // 2. 마스크 블러 처리 (옵션)
                    // 사람이 255인 이미지를 그릴 때, filter를 사용하여 경계를 흐리게 만듭니다.
                    // 이를 위해 별도의 캔버스에 마스크를 그리고 블러를 먹입니다.
                    const finalMaskCanvas = document.createElement('canvas');
                    finalMaskCanvas.width = w;
                    finalMaskCanvas.height = h;
                    const finalMaskCtx = finalMaskCanvas.getContext('2d');
                    
                    if (smoothEdges) {
                        // 고화질일수록 블러 반경을 살짝 넓힘 (3px ~ 4px), 일반은 2px
                        const blurAmount = highQuality ? 4 : 2;
                        finalMaskCtx.filter = `blur(${blurAmount}px)`;
                    }
                    finalMaskCtx.drawImage(maskCanvas, 0, 0);
                    
                    // 3. 원본 이미지와 합성 (Destination-In)
                    // 원본 이미지를 그리고, 그 위에 블러 처리된 마스크를 'destination-in'으로 합성하면
                    // 마스크의 투명도에 따라 원본이 잘리고 경계가 부드러워집니다.
                    const resultCanvas = document.createElement('canvas');
                    resultCanvas.width = w;
                    resultCanvas.height = h;
                    const resultCtx = resultCanvas.getContext('2d');
                    
                    resultCtx.drawImage(processCanvas, 0, 0); // 원본 그리기
                    resultCtx.globalCompositeOperation = 'destination-in'; // 겹치는 부분만 남기기
                    resultCtx.drawImage(finalMaskCanvas, 0, 0); // 마스크 적용

                    setImage(resultCanvas.toDataURL('image/png'));
                    setResize({ width: w, height: Math.floor(h), locked: true });
                    setOriginalDimensions({ w: w, h: Math.floor(h) });
                    
                } catch (error) {
                    console.error(error);
                    alert("처리 중 오류가 발생했습니다. 브라우저 메모리가 부족할 수 있습니다.");
                } finally {
                    setIsProcessing(false);
                }
            };

            const saveImage = () => {
                if (!image) return;
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                img.onload = () => {
                    canvas.width = resize.width;
                    canvas.height = resize.height;
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    if (saveFormat === 'jpg' || saveFormat === 'bmp') {
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                    ctx.filter = `brightness(${filters.brightness}%) contrast(${filters.contrast}%) saturate(${filters.saturation}%) blur(${filters.blur}px) hue-rotate(${filters.hue}deg) sepia(${filters.sepia}%) grayscale(${filters.grayscale}%)`;
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate((transform.rotate * Math.PI) / 180);
                    ctx.scale(transform.flipH, transform.flipV);
                    const isRotated = transform.rotate % 180 !== 0;
                    const drawW = isRotated ? canvas.height : canvas.width;
                    const drawH = isRotated ? canvas.width : canvas.height;
                    ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
                    let mimeType = 'image/png';
                    if (saveFormat === 'jpg') mimeType = 'image/jpeg';
                    else if (saveFormat === 'bmp') mimeType = 'image/bmp';
                    else if (saveFormat === 'webp') mimeType = 'image/webp';
                    const link = document.createElement('a');
                    link.download = `edited-image.${saveFormat}`; 
                    link.href = canvas.toDataURL(mimeType, 0.9);
                    link.click();
                };
                img.crossOrigin = "anonymous";
                img.src = image;
            };

            const getFilterStyle = () => {
                return {
                    filter: `brightness(${filters.brightness}%) contrast(${filters.contrast}%) saturate(${filters.saturation}%) blur(${filters.blur}px) hue-rotate(${filters.hue}deg) sepia(${filters.sepia}%) grayscale(${filters.grayscale}%)`,
                    transform: `rotate(${transform.rotate}deg) scale(${transform.flipH}, ${transform.flipV})`,
                };
            };

            if (!image) {
                return (
                    <div 
                        className="min-h-screen bg-gray-50 flex flex-col items-center justify-center p-4 transition-colors duration-200"
                        onDragOver={handleDragOver}
                        onDragLeave={handleDragLeave}
                        onDrop={handleDrop}
                    >
                        <div className={`bg-white p-12 rounded-2xl shadow-xl w-full max-w-lg text-center border-2 transition-all duration-300 ${isDragging ? 'border-indigo-500 bg-indigo-50/50 scale-105 shadow-2xl' : 'border-dashed border-gray-300 hover:border-gray-400'}`}>
                            <div className={`w-24 h-24 rounded-full flex items-center justify-center mx-auto mb-6 transition-colors duration-300 ${isDragging ? 'bg-indigo-100' : 'bg-indigo-50'}`}>
                                <ImageIcon className={`w-12 h-12 transition-colors duration-300 ${isDragging ? 'text-indigo-600' : 'text-indigo-500'}`} />
                            </div>
                            <h1 className="text-3xl font-bold text-gray-800 mb-3">이미지 에디터(byST)</h1>
                            <p className="text-gray-500 mb-8 text-lg">{isDragging ? '여기에 이미지를 놓으세요!' : '파일을 드래그하거나 아래 버튼을 눌러주세요'}</p>
                            <input type="file" accept="image/*" ref={fileInputRef} onChange={handleImageUpload} className="hidden" />
                            <button onClick={() => fileInputRef.current.click()} className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-4 px-6 rounded-xl transition duration-200 flex items-center justify-center gap-2 shadow-lg shadow-indigo-200 text-lg group">
                                <Upload size={24} className="group-hover:scale-110 transition-transform"/>
                                이미지 불러오기
                            </button>
                        </div>
                    </div>
                );
            }

            return (
                <div className="min-h-screen bg-gray-900 flex flex-col md:flex-row text-white h-screen overflow-hidden">
                <div className="flex-1 relative bg-gray-900/50 flex items-center justify-center p-8 overflow-hidden select-none">
                    <div className="relative shadow-2xl overflow-hidden max-w-full max-h-full flex items-center justify-center">
                    <div className="absolute inset-0 bg-[url('https://t3.ftcdn.net/jpg/03/76/74/78/360_F_376747823_L8i8k8X4t4Qj0i0iFjFjFjFjFjFjFjFj.jpg')] opacity-20 bg-repeat z-0 pointer-events-none"></div>
                    {isProcessing && (
                        <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/70 backdrop-blur-sm">
                            <Loader2 className="w-12 h-12 text-indigo-500 animate-spin mb-4" />
                            <p className="text-white font-medium text-lg">AI 분석 및 처리 중...</p>
                            <p className="text-gray-400 text-sm mt-1">{highQuality ? '고화질 모드는 시간이 더 걸릴 수 있습니다' : '잠시만 기다려주세요'}</p>
                        </div>
                    )}
                    <img src={image} alt="Preview" style={getFilterStyle()} className="max-w-full max-h-[85vh] object-contain transition-all duration-200 ease-out z-10" />
                    </div>
                    <div className="absolute top-4 left-4 flex gap-2 z-20">
                        <button onClick={() => setImage(null)} className="bg-black/40 hover:bg-black/60 p-2 rounded-lg backdrop-blur-sm transition text-white" title="새 이미지">
                            <Trash2 size={20} className="text-red-400"/>
                        </button>
                        <div className="bg-black/40 text-white px-3 py-2 rounded-lg backdrop-blur-sm text-sm font-mono">
                            현재: {(currentFileSize / 1024).toFixed(1)} KB
                        </div>
                    </div>
                </div>

                <div className="w-full md:w-80 bg-white text-gray-800 flex flex-col h-[40vh] md:h-full shadow-2xl z-10 border-l border-gray-200">
                    <div className="p-4 border-b border-gray-100 flex justify-between items-center bg-white">
                    <h2 className="font-bold text-lg text-gray-800">편집 도구</h2>
                    <div className="flex gap-2 items-center">
                        <button onClick={resetEdits} className="p-2 text-gray-500 hover:text-indigo-600 hover:bg-indigo-50 rounded-lg transition" title="모두 초기화">
                        <RefreshCcw size={18} />
                        </button>
                        <div className="flex bg-indigo-50 rounded-lg p-0.5 border border-indigo-100">
                            <select value={saveFormat} onChange={(e) => setSaveFormat(e.target.value)} className="bg-transparent text-xs font-semibold text-indigo-700 px-2 outline-none cursor-pointer">
                                <option value="png">PNG</option>
                                <option value="jpg">JPG</option>
                                <option value="bmp">BMP</option>
                                <option value="webp">WEBP</option>
                            </select>
                            <button onClick={saveImage} disabled={isProcessing} className="bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-1.5 rounded-md text-sm font-semibold flex items-center gap-1 transition shadow-sm disabled:opacity-50">
                                <Save size={14} /> 저장
                            </button>
                        </div>
                    </div>
                    </div>

                    <div className="flex border-b border-gray-100 overflow-x-auto">
                    {[
                        { id: 'adjust', label: '보정', icon: Sliders },
                        { id: 'filter', label: '필터', icon: Droplet },
                        { id: 'transform', label: '변형', icon: Move },
                        { id: 'resize', label: '크기', icon: Scaling },
                        { id: 'eraser', label: 'AI 누끼', icon: Wand2 },
                    ].map((tab) => (
                        <button key={tab.id} onClick={() => handleTabChange(tab.id)} disabled={isProcessing} className={`flex-1 py-4 px-2 text-xs md:text-sm font-medium flex flex-col items-center gap-1 transition-colors min-w-[60px] ${activeTab === tab.id ? 'text-indigo-600 border-b-2 border-indigo-600 bg-indigo-50/50' : 'text-gray-400 hover:text-gray-600 hover:bg-gray-50'}`}>
                        <tab.icon size={18} /> {tab.label}
                        </button>
                    ))}
                    </div>

                    <div className="flex-1 overflow-y-auto p-6 space-y-6">
                    {activeTab === 'adjust' && (
                        <div className="space-y-6">
                        <FilterControl label="밝기" value={filters.brightness} min={0} max={200} onChange={(v) => setFilters(p => ({...p, brightness: v}))} icon={<Sun size={16} />} />
                        <FilterControl label="대비" value={filters.contrast} min={0} max={200} onChange={(v) => setFilters(p => ({...p, contrast: v}))} icon={<Contrast size={16} />} />
                        <FilterControl label="채도" value={filters.saturation} min={0} max={200} onChange={(v) => setFilters(p => ({...p, saturation: v}))} icon={<Activity size={16} />} />
                        <FilterControl label="흐림" value={filters.blur} min={0} max={20} onChange={(v) => setFilters(p => ({...p, blur: v}))} icon={<Droplet size={16} />} />
                        </div>
                    )}

                    {activeTab === 'filter' && (
                        <div className="grid grid-cols-2 gap-3">
                        <PresetButton label="원본" onClick={() => applyPreset('default')} active={false} />
                        <PresetButton label="화사한(얼굴)" onClick={() => applyPreset('beauty')} active={false} />
                        <PresetButton label="뚜렷한" onClick={() => applyPreset('sharp')} active={false} />
                        <PresetButton label="부드러운" onClick={() => applyPreset('soft')} active={false} />
                        <PresetButton label="맑은" onClick={() => applyPreset('clear')} active={false} />
                        <PresetButton label="강렬한" onClick={() => applyPreset('intense')} active={false} />
                        <PresetButton label="따뜻한" onClick={() => applyPreset('warm')} active={false} />
                        <PresetButton label="차가운" onClick={() => applyPreset('cool')} active={false} />
                        <PresetButton label="흑백" onClick={() => applyPreset('grayscale')} active={filters.grayscale === 100} />
                        <PresetButton label="세피아" onClick={() => applyPreset('sepia')} active={filters.sepia === 100} />
                        <PresetButton label="빈티지" onClick={() => applyPreset('vintage')} active={false} />
                        </div>
                    )}

                    {activeTab === 'transform' && (
                        <div className="space-y-6">
                        <div className="space-y-3">
                                <label className="text-sm font-bold text-gray-700">90도 단위 회전</label>
                                <div className="grid grid-cols-4 gap-2">
                                    {[0, 90, 180, 270].map(deg => (
                                        <button key={deg} onClick={() => setTransform(p => ({...p, rotate: deg}))} className={`py-2 rounded-lg text-xs font-medium border ${transform.rotate === deg ? 'bg-indigo-600 text-white border-indigo-600' : 'bg-white text-gray-600 border-gray-200 hover:bg-gray-50'}`}>
                                            {deg}°
                                        </button>
                                    ))}
                                </div>
                        </div>
                        <div className="grid grid-cols-2 gap-3">
                            <TransformButton onClick={() => setTransform(p => ({...p, rotate: (p.rotate - 90 + 360) % 360}))} icon={<RotateCcw size={20} />} label="왼쪽 90°" />
                            <TransformButton onClick={() => setTransform(p => ({...p, rotate: (p.rotate + 90) % 360}))} icon={<RotateCw size={20} />} label="오른쪽 90°" />
                            <TransformButton onClick={() => setTransform(p => ({...p, flipH: p.flipH * -1}))} icon={<FlipHorizontal size={20} />} label="좌우 반전" />
                            <TransformButton onClick={() => setTransform(p => ({...p, flipV: p.flipV * -1}))} icon={<FlipVertical size={20} />} label="상하 반전" />
                        </div>
                        <div className="bg-gray-50 p-4 rounded-xl text-center text-sm text-gray-500">
                            현재 각도: <span className="font-bold text-indigo-600">{transform.rotate}°</span>
                        </div>
                        </div>
                    )}

                    {activeTab === 'resize' && (
                        <div className="space-y-8">
                            <div className="space-y-4">
                                <div className="flex items-center justify-between">
                                    <span className="text-sm font-bold text-gray-700">1. 크기 조절 (픽셀)</span>
                                    <button onClick={() => setResize(p => ({...p, locked: !p.locked}))} className={`p-2 rounded-lg ${resize.locked ? 'text-indigo-600 bg-indigo-50' : 'text-gray-400 bg-gray-100'}`} title="비율 잠금">
                                        {resize.locked ? <Lock size={16} /> : <Unlock size={16} />}
                                    </button>
                                </div>
                                <div><label className="block text-xs text-gray-500 mb-1">너비 (Width)</label><input type="number" value={resize.width} onChange={(e) => handleResizeChange('width', e.target.value)} className="w-full px-4 py-2 border border-gray-200 rounded-xl focus:ring-2 focus:ring-indigo-500 outline-none" /></div>
                                <div><label className="block text-xs text-gray-500 mb-1">높이 (Height)</label><input type="number" value={resize.height} onChange={(e) => handleResizeChange('height', e.target.value)} className="w-full px-4 py-2 border border-gray-200 rounded-xl focus:ring-2 focus:ring-indigo-500 outline-none" /></div>
                                <div className="text-xs text-gray-400 text-center pt-2">원본: {originalDimensions.w} x {originalDimensions.h} px</div>
                            </div>
                            <hr className="border-gray-100" />
                            <div className="space-y-4">
                                <div className="flex items-center gap-2">
                                    <HardDrive size={18} className="text-indigo-600"/>
                                    <span className="text-sm font-bold text-gray-700">2. 용량으로 조절 (압축)</span>
                                </div>
                                <div className="bg-orange-50 p-3 rounded-lg text-xs text-orange-800">* 압축 시 JPEG로 변환되어 투명 배경은 <strong>흰색</strong>이 됩니다.<br/>* 현재 필터 및 크기 설정이 모두 적용됩니다.</div>
                                <div className="flex items-end gap-2">
                                    <div className="flex-1"><label className="block text-xs text-gray-500 mb-1">목표 용량 (KB)</label><input type="number" value={targetKb} onChange={(e) => setTargetKb(Number(e.target.value))} className="w-full px-4 py-2 border border-gray-200 rounded-xl focus:ring-2 focus:ring-indigo-500 outline-none" placeholder="예: 500" /></div>
                                    <button onClick={compressToTargetSize} disabled={isProcessing} className="h-[42px] px-4 bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-semibold rounded-xl shadow-md transition whitespace-nowrap disabled:opacity-50">맞추기</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {activeTab === 'eraser' && (
                        <div className="space-y-6">
                            <div className="text-center space-y-4">
                                <div className="bg-indigo-50 p-4 rounded-xl text-indigo-800 text-sm">
                                    <strong>AI 자동 배경 제거</strong>
                                    <p className="mt-1 opacity-80 text-xs">사진 속 인물을 인식하여 배경을 지웁니다.</p>
                                </div>
                                
                                {/* 옵션 컨트롤 */}
                                <div className="bg-gray-50 rounded-xl p-4 space-y-3 text-left">
                                    <label className="flex items-center justify-between cursor-pointer group">
                                        <div className="flex items-center gap-2">
                                            <div className={`w-4 h-4 rounded border flex items-center justify-center ${highQuality ? 'bg-indigo-600 border-indigo-600' : 'bg-white border-gray-300'}`}>
                                                {highQuality && <div className="w-2 h-2 bg-white rounded-sm"></div>}
                                            </div>
                                            <span className="text-sm font-medium text-gray-700 group-hover:text-indigo-700">고화질 모드 (느림)</span>
                                        </div>
                                        <input type="checkbox" checked={highQuality} onChange={(e) => setHighQuality(e.target.checked)} className="hidden" />
                                    </label>
                                    <p className="text-xs text-gray-400 pl-6">이미지 크기를 덜 줄이고 정밀하게 분석합니다.<br/>(메모리 부족 시 작동이 멈출 수 있습니다)</p>
                                    
                                    <hr className="border-gray-200"/>

                                    <label className="flex items-center justify-between cursor-pointer group">
                                        <div className="flex items-center gap-2">
                                            <div className={`w-4 h-4 rounded border flex items-center justify-center ${smoothEdges ? 'bg-indigo-600 border-indigo-600' : 'bg-white border-gray-300'}`}>
                                                {smoothEdges && <div className="w-2 h-2 bg-white rounded-sm"></div>}
                                            </div>
                                            <span className="text-sm font-medium text-gray-700 group-hover:text-indigo-700">가장자리 부드럽게</span>
                                        </div>
                                        <input type="checkbox" checked={smoothEdges} onChange={(e) => setSmoothEdges(e.target.checked)} className="hidden" />
                                    </label>
                                    <p className="text-xs text-gray-400 pl-6">경계선을 흐리게 처리하여 자연스럽게 만듭니다.</p>
                                </div>

                                <button onClick={removeBackground} disabled={isProcessing} className="w-full bg-gradient-to-r from-indigo-600 to-violet-600 hover:from-indigo-700 hover:to-violet-700 text-white py-4 rounded-xl font-bold flex items-center justify-center gap-2 shadow-lg shadow-indigo-200 transition disabled:opacity-50 disabled:cursor-not-allowed">
                                {isProcessing ? (
                                    <> <Loader2 size={20} className="animate-spin" /> 분석 중... </>
                                ) : (
                                    <> <Wand2 size={20} /> 배경 제거 실행 </>
                                )}
                                </button>
                                <p className="text-xs text-gray-400">* 사람이 명확하게 나온 사진이 결과가 좋습니다.</p>
                            </div>
                        </div>
                    )}

                    </div>
                </div>
                </div>
            );
        }

        function FilterControl({ label, value, min, max, onChange, icon }) {
            return (
                <div className="space-y-2">
                <div className="flex justify-between text-sm text-gray-600 mb-1">
                    <div className="flex items-center gap-2">{icon}<span className="font-medium">{label}</span></div>
                    <span className="bg-gray-100 px-2 py-0.5 rounded text-xs text-gray-500 font-mono">{value}</span>
                </div>
                <input type="range" min={min} max={max} value={value} onChange={(e) => onChange(Number(e.target.value))} className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-indigo-600 hover:accent-indigo-500 transition-all" />
                </div>
            );
        }

        function PresetButton({ label, onClick, active }) {
            return <button onClick={onClick} className={`py-3 px-4 rounded-xl text-sm font-medium transition-all duration-200 ${active ? 'bg-indigo-600 text-white shadow-md shadow-indigo-200' : 'bg-white border border-gray-200 text-gray-700 hover:border-indigo-300 hover:bg-indigo-50'}`}>{label}</button>;
        }

        function TransformButton({ onClick, icon, label }) {
            return (
                <button onClick={onClick} className="flex flex-col items-center justify-center gap-2 p-4 bg-white border border-gray-200 rounded-xl hover:bg-indigo-50 hover:border-indigo-200 hover:text-indigo-600 transition-all group">
                    <div className="text-gray-600 group-hover:text-indigo-600">{icon}</div>
                    <span className="text-xs font-medium text-gray-600 group-hover:text-indigo-600">{label}</span>
                </button>
            )
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>
