<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>말랑이의 모험 (Cute Mario Ver)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Gaegu:wght@700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #FFF5E4; /* 따뜻한 크림색 배경 */
            font-family: 'Gaegu', cursive;
            touch-action: none; /* 모바일에서 더블탭 확대 방지 */
        }

        #gameCanvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .score-board {
            padding: 20px;
            font-size: 30px;
            color: #FF6B6B;
            text-shadow: 2px 2px 0px #FFF;
        }

        .center-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(255, 255, 255, 0.9);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            pointer-events: auto;
            border: 5px solid #FFD93D;
        }

        .center-msg h1 {
            margin: 0 0 10px 0;
            font-family: 'Fredoka One', cursive;
            color: #FF6B6B;
            font-size: 40px;
        }

        .center-msg p {
            font-size: 20px;
            color: #555;
            margin-bottom: 20px;
        }

        .btn {
            background: #FFD93D;
            border: none;
            padding: 10px 30px;
            font-size: 24px;
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Gaegu', cursive;
            color: #555;
            transition: transform 0.1s;
            box-shadow: 0 5px 0 #E5C335;
        }

        .btn:active {
            transform: translateY(5px);
            box-shadow: none;
        }

        /* 모바일 컨트롤러 */
        #mobile-controls {
            display: none;
            pointer-events: auto;
            padding: 20px;
            justify-content: space-between;
            align-items: flex-end;
            height: 150px;
        }

        .control-btn {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            user-select: none;
            border: 3px solid #FFB7B2;
            color: #FFB7B2;
        }

        .control-btn:active {
            background: #FFB7B2;
            color: white;
        }

        .d-pad {
            display: flex;
            gap: 15px;
        }

        @media (hover: none) and (pointer: coarse) {
            #mobile-controls {
                display: flex;
            }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="score-board">⭐️ <span id="score">0</span></div>
        
        <div id="start-screen" class="center-msg">
            <h1>말랑이의 모험</h1>
            <p>화살표 키로 이동하고<br>스페이스바로 점프하세요!</p>
            <button class="btn" onclick="startGame()">게임 시작</button>
        </div>

        <div id="game-over-screen" class="center-msg" style="display: none;">
            <h1>게임 오버!</h1>
            <p>다시 도전해볼까요?</p>
            <button class="btn" onclick="resetGame()">다시하기</button>
        </div>

        <div id="win-screen" class="center-msg" style="display: none;">
            <h1>성공!</h1>
            <p>모든 여정을 마쳤어요!<br>정말 대단해요!</p>
            <button class="btn" onclick="resetGame()">처음부터</button>
        </div>

        <div id="mobile-controls">
            <div class="d-pad">
                <div class="control-btn" id="btn-left">◀</div>
                <div class="control-btn" id="btn-right">▶</div>
            </div>
            <div class="control-btn" id="btn-jump">J</div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');

    // 게임 상태 변수
    let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER, WIN
    let animationId;
    let score = 0;
    let cameraX = 0;

    // 물리 상수
    const GRAVITY = 0.6;
    const FRICTION = 0.8;
    const JUMP_FORCE = -13;
    const MOVE_SPEED = 5;

    // 입력 상태
    const keys = {
        left: false,
        right: false,
        up: false
    };

    // 게임 객체들
    let player;
    let platforms = [];
    let enemies = [];
    let particles = [];
    let goal;
    let stars = [];

    // 화면 크기 조정
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // 유틸리티 함수: 랜덤 색상 (파스텔톤)
    function getRandomPastel() {
        const hue = Math.floor(Math.random() * 360);
        return `hsl(${hue}, 70%, 80%)`;
    }

    // --- 클래스 정의 ---

    class Player {
        constructor() {
            this.x = 100;
            this.y = 300;
            this.width = 40;
            this.height = 40;
            this.vx = 0;
            this.vy = 0;
            this.color = '#FF9EAA'; // 귀여운 핑크
            this.grounded = false;
            this.facingRight = true;
            this.eyeOffset = 0;
            this.blinkTimer = 0;
        }

        update() {
            // 이동
            if (keys.left) {
                this.vx = -MOVE_SPEED;
                this.facingRight = false;
            }
            if (keys.right) {
                this.vx = MOVE_SPEED;
                this.facingRight = true;
            }
            if (!keys.left && !keys.right) {
                this.vx *= FRICTION;
            }

            // 점프
            if (keys.up && this.grounded) {
                this.vy = JUMP_FORCE;
                this.grounded = false;
                createParticles(this.x + this.width/2, this.y + this.height, 5, '#FFF');
            }

            // 중력
            this.vy += GRAVITY;

            // 위치 적용
            this.x += this.vx;
            this.y += this.vy;

            // 낙하사
            if (this.y > canvas.height + 200) {
                gameOver();
            }

            // 눈 깜빡임 타이머
            this.blinkTimer++;
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x + this.width/2, this.y + this.height/2);
            
            // 몸통 (말랑한 느낌을 위해 점프 시 찌그러짐)
            let scaleX = 1;
            let scaleY = 1;
            if (!this.grounded) {
                scaleX = 0.9;
                scaleY = 1.1;
            } else if (Math.abs(this.vx) > 0.1) {
                scaleY = 1 - Math.abs(this.vx * 0.02);
                scaleX = 1 + Math.abs(this.vx * 0.02);
            }

            ctx.scale(scaleX, scaleY);

            // 귀
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.ellipse(-12, -15, 8, 15, -0.2, 0, Math.PI * 2);
            ctx.ellipse(12, -15, 8, 15, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // 얼굴
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2);
            ctx.fill();

            // 눈 (깜빡임 구현)
            ctx.fillStyle = '#333';
            if (this.blinkTimer % 150 < 10) {
                // 감은 눈
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(-10, -2); ctx.lineTo(-4, -2);
                ctx.moveTo(4, -2); ctx.lineTo(10, -2);
                ctx.stroke();
            } else {
                // 뜬 눈
                const eyeX = this.facingRight ? 4 : -4;
                ctx.beginPath();
                ctx.arc(-8 + eyeX, -2, 2.5, 0, Math.PI * 2);
                ctx.arc(8 + eyeX, -2, 2.5, 0, Math.PI * 2);
                ctx.fill();
            }

            // 볼터치
            ctx.fillStyle = '#FFD1DC';
            ctx.beginPath();
            ctx.arc(-12, 5, 4, 0, Math.PI * 2);
            ctx.arc(12, 5, 4, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }
    }

    class Platform {
        constructor(x, y, width, height, type = 'normal') {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.type = type; // normal, cloud, ground
        }

        draw(ctx) {
            if (this.type === 'ground') {
                ctx.fillStyle = '#B5EAD7'; // 민트색 땅
                ctx.beginPath();
                ctx.roundRect(this.x, this.y, this.width, this.height, 10);
                ctx.fill();
                // 윗부분 풀 장식
                ctx.fillStyle = '#95DAB6';
                ctx.fillRect(this.x, this.y, this.width, 10);
            } else if (this.type === 'cloud') {
                ctx.fillStyle = '#E2F0CB'; // 연두색 구름
                // 구름 모양 그리기 (원 여러개)
                ctx.beginPath();
                ctx.arc(this.x + 20, this.y + 20, 20, 0, Math.PI * 2);
                ctx.arc(this.x + this.width - 20, this.y + 20, 20, 0, Math.PI * 2);
                ctx.rect(this.x + 20, this.y, this.width - 40, 40);
                ctx.fill();
            } else {
                ctx.fillStyle = '#FFDAC1'; // 살구색 벽돌
                ctx.beginPath();
                ctx.roundRect(this.x, this.y, this.width, this.height, 5);
                ctx.fill();
                ctx.strokeStyle = '#FFB7B2';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }
    }

    class Enemy {
        constructor(x, y, range) {
            this.x = x;
            this.y = y;
            this.width = 35;
            this.height = 35;
            this.startX = x;
            this.range = range;
            this.speed = 1.5;
            this.vx = 1.5;
            this.color = '#C7CEEA'; // 라벤더색 몬스터
            this.dead = false;
        }

        update() {
            if (this.dead) return;

            this.x += this.vx;

            // 순찰 로직
            if (this.x > this.startX + this.range || this.x < this.startX) {
                this.vx *= -1;
            }
        }

        draw(ctx) {
            if (this.dead) return;
            
            ctx.save();
            ctx.translate(this.x + this.width/2, this.y + this.height/2);
            
            // 젤리같은 몬스터
            ctx.fillStyle = this.color;
            
            // 움직임에 따라 꿀렁거림
            const bounce = Math.sin(Date.now() / 200) * 2;
            
            ctx.beginPath();
            ctx.moveTo(-18, 18);
            ctx.bezierCurveTo(-18, -25 + bounce, 18, -25 + bounce, 18, 18);
            ctx.fill();

            // 화난 눈
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-6, -5 + bounce, 5, 0, Math.PI * 2);
            ctx.arc(6, -5 + bounce, 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(-6, -5 + bounce, 2, 0, Math.PI * 2);
            ctx.arc(6, -5 + bounce, 2, 0, Math.PI * 2);
            ctx.fill();

            // 송곳니
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(-3, 2 + bounce); ctx.lineTo(-1, 6 + bounce); ctx.lineTo(1, 2 + bounce);
            ctx.fill();

            ctx.restore();
        }
    }

    class Star {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.width = 30;
            this.height = 30;
            this.collected = false;
            this.baseY = y;
            this.offset = Math.random() * Math.PI * 2;
        }

        update() {
            if (this.collected) return;
            // 둥둥 떠다니는 효과
            this.y = this.baseY + Math.sin(Date.now() / 500 + this.offset) * 5;
        }

        draw(ctx) {
            if (this.collected) return;
            ctx.fillStyle = '#FFD93D';
            ctx.save();
            ctx.translate(this.x + this.width/2, this.y + this.height/2);
            ctx.rotate(Date.now() / 1000);
            
            // 별 그리기
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                ctx.lineTo(Math.cos((18 + i * 72) * Math.PI / 180) * 15,
                           -Math.sin((18 + i * 72) * Math.PI / 180) * 15);
                ctx.lineTo(Math.cos((54 + i * 72) * Math.PI / 180) * 7,
                           -Math.sin((54 + i * 72) * Math.PI / 180) * 7);
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 4;
            this.vy = (Math.random() - 0.5) * 4;
            this.life = 1.0;
            this.color = color;
            this.size = Math.random() * 5 + 2;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= 0.02;
            this.size *= 0.95;
        }
        draw(ctx) {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    class Goal {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.width = 40;
            this.height = 100;
        }
        draw(ctx) {
            // 깃대
            ctx.fillStyle = '#8D6E63';
            ctx.fillRect(this.x + 15, this.y, 10, this.height);
            
            // 깃발
            ctx.fillStyle = '#FF6B6B';
            ctx.beginPath();
            ctx.moveTo(this.x + 25, this.y + 10);
            ctx.lineTo(this.x + 60, this.y + 30);
            ctx.lineTo(this.x + 25, this.y + 50);
            ctx.fill();
        }
    }

    // --- 게임 로직 함수 ---

    function createParticles(x, y, count, color) {
        for(let i=0; i<count; i++) {
            particles.push(new Particle(x, y, color));
        }
    }

    function checkCollision(r1, r2) {
        return (r1.x < r2.x + r2.width &&
                r1.x + r1.width > r2.x &&
                r1.y < r2.y + r2.height &&
                r1.y + r1.height > r2.y);
    }

    function initLevel() {
        player = new Player();
        platforms = [];
        enemies = [];
        stars = [];
        particles = [];
        score = 0;
        scoreEl.textContent = score;
        cameraX = 0;

        // 바닥
        for(let i=0; i<50; i++) {
            platforms.push(new Platform(i * 100, canvas.height - 50, 100, 50, 'ground'));
        }

        // 플랫폼 및 장애물 배치 (간단한 레벨 디자인)
        // 플랫폼: x, y, w, h, type
        const levelData = [
            // 초반 튜토리얼 점프
            {x: 400, y: canvas.height - 150, w: 120, h: 30, t: 'cloud'},
            {x: 600, y: canvas.height - 250, w: 120, h: 30, t: 'cloud'},
            
            // 몬스터 구간
            {x: 900, y: canvas.height - 180, w: 200, h: 30, t: 'normal'},
            
            // 높은 점프
            {x: 1300, y: canvas.height - 300, w: 100, h: 30, t: 'cloud'},
            {x: 1500, y: canvas.height - 400, w: 100, h: 30, t: 'cloud'},
            
            // 다리 건너기
            {x: 1800, y: canvas.height - 250, w: 400, h: 30, t: 'normal'},
            
            // 마지막 난관
            {x: 2300, y: canvas.height - 350, w: 100, h: 30, t: 'cloud'},
            {x: 2500, y: canvas.height - 200, w: 100, h: 30, t: 'cloud'},
        ];

        levelData.forEach(p => {
            platforms.push(new Platform(p.x, p.y, p.w, p.h, p.t));
        });

        // 몬스터 배치
        enemies.push(new Enemy(900, canvas.height - 180 - 35, 150));
        enemies.push(new Enemy(1900, canvas.height - 250 - 35, 150));
        enemies.push(new Enemy(1300, canvas.height - 50 - 35, 200));

        // 별 배치
        const starCoords = [450, 650, 1000, 1550, 2000, 2550];
        starCoords.forEach(x => {
            stars.push(new Star(x, canvas.height - 450)); // 높이 대충 설정
        });
        
        // 별 높이 조정 (플랫폼 위로)
        stars.forEach(s => {
             // 가장 가까운 아래 플랫폼 찾기
             let groundY = canvas.height - 50;
             platforms.forEach(p => {
                 if(s.x > p.x && s.x < p.x + p.width && p.y < groundY && p.y > s.y) {
                     // s.y = p.y - 60; // 로직 단순화를 위해 생략하거나 고정 위치 사용
                 }
             });
        });
        
        // 별 위치 하드코딩 수정 (더 예쁘게)
        stars = [
            new Star(450, canvas.height - 220),
            new Star(650, canvas.height - 320),
            new Star(1000, canvas.height - 250),
            new Star(1550, canvas.height - 470),
            new Star(2000, canvas.height - 320),
            new Star(2550, canvas.height - 270)
        ];

        goal = new Goal(2800, canvas.height - 150);
    }

    function update() {
        if (gameState !== 'PLAYING') return;

        player.update();
        player.grounded = false;

        // 플랫폼 충돌 처리
        platforms.forEach(platform => {
            if (checkCollision(player, platform)) {
                // 플레이어 바닥이 플랫폼 윗면과 닿을 때 (위에서 아래로 떨어질 때)
                if (player.vy > 0 && player.y + player.height - player.vy <= platform.y + 10) {
                    player.grounded = true;
                    player.vy = 0;
                    player.y = platform.y - player.height;
                }
                // 머리가 닿을 때 (아래에서 위로)
                else if (player.vy < 0 && player.y - player.vy >= platform.y + platform.height) {
                    player.vy = 0;
                    player.y = platform.y + platform.height;
                }
                // 옆면 충돌 (간단하게 구현)
                else {
                    // 보통 마리오류는 옆면 미끄러짐이 있지만 여기선 생략하거나 간단히 처리
                }
            }
        });

        // 몬스터 충돌 처리
        enemies.forEach(enemy => {
            enemy.update();
            if (!enemy.dead && checkCollision(player, enemy)) {
                // 밟았을 때
                if (player.vy > 0 && player.y + player.height - player.vy <= enemy.y + enemy.height/2) {
                    enemy.dead = true;
                    player.vy = -8; // 튀어오르기
                    createParticles(enemy.x, enemy.y, 10, enemy.color);
                    score += 100;
                    scoreEl.textContent = score;
                } else {
                    // 부딪혔을 때
                    gameOver();
                }
            }
        });

        // 별 획득
        stars.forEach(star => {
            star.update();
            if (!star.collected && checkCollision(player, star)) {
                star.collected = true;
                score += 50;
                scoreEl.textContent = score;
                createParticles(star.x, star.y, 8, '#FFD93D');
            }
        });

        // 파티클 업데이트
        particles = particles.filter(p => p.life > 0);
        particles.forEach(p => p.update());

        // 목표 도달
        if (checkCollision(player, goal)) {
            gameWin();
        }

        // 카메라 이동 (플레이어가 화면 중앙을 넘어가면)
        const targetCamX = player.x - canvas.width / 3;
        cameraX += (targetCamX - cameraX) * 0.1; // 부드러운 카메라
        if (cameraX < 0) cameraX = 0; // 시작점 왼쪽으로 못가게
        if (cameraX > goal.x - canvas.width + 200) cameraX = goal.x - canvas.width + 200;
    }

    function draw() {
        // 배경 그리기 (파스텔 하늘)
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#E0F7FA'); // 연한 하늘색
        gradient.addColorStop(1, '#FFF5E4'); // 연한 크림색
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(-Math.floor(cameraX), 0);

        // 배경 장식 (먼 산 등) - 간단히 원으로 표현
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.beginPath();
        ctx.arc(200, canvas.height, 300, 0, Math.PI * 2);
        ctx.arc(800, canvas.height + 100, 400, 0, Math.PI * 2);
        ctx.fill();

        // 객체 그리기
        goal.draw(ctx);
        platforms.forEach(p => p.draw(ctx));
        stars.forEach(s => s.draw(ctx));
        enemies.forEach(e => e.draw(ctx));
        player.draw(ctx);
        particles.forEach(p => p.draw(ctx));

        ctx.restore();
    }

    function gameLoop() {
        update();
        draw();
        animationId = requestAnimationFrame(gameLoop);
    }

    function startGame() {
        document.getElementById('start-screen').style.display = 'none';
        initLevel();
        gameState = 'PLAYING';
        gameLoop();
    }

    function gameOver() {
        gameState = 'GAMEOVER';
        cancelAnimationFrame(animationId);
        document.getElementById('game-over-screen').style.display = 'block';
    }

    function gameWin() {
        gameState = 'WIN';
        cancelAnimationFrame(animationId);
        document.getElementById('win-screen').style.display = 'block';
        createParticles(canvas.width/2 + cameraX, canvas.height/2, 50, '#FFD93D');
        draw(); // 마지막 상태 그리기
    }

    function resetGame() {
        document.getElementById('game-over-screen').style.display = 'none';
        document.getElementById('win-screen').style.display = 'none';
        startGame();
    }

    // --- 입력 처리 ---

    window.addEventListener('keydown', e => {
        if (gameState !== 'PLAYING') return;
        switch(e.code) {
            case 'ArrowLeft': keys.left = true; break;
            case 'ArrowRight': keys.right = true; break;
            case 'Space':
            case 'ArrowUp': 
                keys.up = true; 
                if (e.code === 'Space') e.preventDefault(); // 스크롤 방지
                break;
        }
    });

    window.addEventListener('keyup', e => {
        switch(e.code) {
            case 'ArrowLeft': keys.left = false; break;
            case 'ArrowRight': keys.right = false; break;
            case 'Space':
            case 'ArrowUp': keys.up = false; break;
        }
    });

    // 모바일 터치 이벤트
    const btnLeft = document.getElementById('btn-left');
    const btnRight = document.getElementById('btn-right');
    const btnJump = document.getElementById('btn-jump');

    const addTouch = (elem, key) => {
        elem.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; });
        elem.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; });
        elem.addEventListener('mousedown', (e) => { keys[key] = true; });
        elem.addEventListener('mouseup', (e) => { keys[key] = false; });
    };

    addTouch(btnLeft, 'left');
    addTouch(btnRight, 'right');
    addTouch(btnJump, 'up');

    // 초기 화면 그리기
    resize();
    ctx.font = "30px 'Gaegu'";
    ctx.fillStyle = "#555";
    ctx.textAlign = "center";
    
</script>
</body>
</html>